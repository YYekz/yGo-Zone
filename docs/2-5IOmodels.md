
# Linux的五种IO模型

## 前置概念

### 用户空间、内核空间

现在操作系统都是采用虚拟存储器，对于32为操作系统而言，寻址空间（虚拟存储空间）为4G（2^32）。**操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限**。为了保证用户进程不能直接操作内核，保证内核的安全，操作系统将虚拟内存划分为两部分。对于Linux来说，
- 将最高1G字节（0xC0000000 - 0xFFFFFFFF）提供给内核使用，成为**内核空间**。
- 将较低的3G字节（0x00000000 - 0xBFFFFFFF）供各个进程使用，成为**用户空间**。
### 进程切换
为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行，这种行为成为进程切换。
从一个进程的运行切换到另一个进程上运行，这个过程中经过了下面这些变化：

1. 保存处理机上下文，包括程序计数器和其他寄存器。
2. 更新PCB信息。
3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。
4. 选择另一个进程执行，并更新其PCB。
5. 更新内存管理的数据结构。
6. 恢复处理机上下文。

可以看出是非常消耗资源的。

### 进程阻塞

当前正在执行的进程由于某些事件未发生（请求资源失败、等待某种操作完成等）导致无新工作可做，则由系统自动执行阻塞，是自己由运行状态变化为阻塞状态。
进入阻塞状态是进程资深的主动性为，也因为只有处于运行状态（获得CPU）的进程，才能将其转化为阻塞状态。
**当进程进入阻塞状态，是不占用CPU资源的。**

### 文件描述符fd

一个用于表述指向文件的引用的抽象化概念。

文件描述符在形式上是一个非负整数。实际上是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。

### 缓存IO

缓存IO又叫做标准IO，大多数文件系统的默认IO都是缓存IO。在Linux的缓存IO机制中，操作系统将IO的数据缓存在文件系统的page cache（页缓存）中，也就是说，数据会先从磁盘被拷贝到操作系统的内核缓冲区，然后再从操作系统的内核缓冲区拷贝到用户应用进程的地址空间。这也是缓存IO的缺点，数据在传输的过程中需要在应用程序地址空间和内核空间进行多次数据拷贝，这些拷贝操作所带来的CPU以及内存开销是很大的。

## Linux IO模型
网络IO的本质是socket的读取，socket在Linux系统中被抽象为流，IO可以理解为对流的操作。从刚才缓存IO中的数据拷贝操作来看，当一个read操作发生时，会经历两个阶段：

1. 第一阶段：等待数据准备；
2. 第二阶段：将数据从内核拷贝到进程中。

对于socket流而言，

1. 第一步：通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区；
2. 第二部：把数据从内核缓冲区拷贝到应用进程缓冲区。

网络应用需要处理的无非就是两大类问题：网络IO和数据计算。网络IO给应用带来的性能瓶颈远大于数据计算。网络IO的模型大致分为如下几种：

1. 同步IO
2. 异步IO
3. 阻塞IO
4. 非阻塞IO
5. 多路复用IO
6. 信号驱动式IO（信号驱动IO在实际中并不常用）

### 同步阻塞IO
同步阻塞IO是最常见的一个模型，也是最简单的模型。在Linux中，默认情况下所有的socket都是blocking。

在这个模型中，用户空间的应用程序执行一个系统调用`recvform`，会导致应用程序阻塞，知道数据准备好，再将数据从内核空间复制到用户进程的内存中，最后进程再处理数据，**等待数据到处理数据的两个阶段，整个进程都被阻塞，不能处理其他事务。** 大致如下图：

![同步阻塞IO](https://upload-images.jianshu.io/upload_images/2062729-41550941d72be698.png?imageMogr2/auto-orient/strip|imageView2/2/w/1184/format/webp)

#### 优点：足够简单，无延迟；
#### 缺点：阻塞明显，性能；

### 同步非阻塞IO
同步非阻塞就是轮询的方式。也就是说非阻塞的`recvform`系统调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据没准备好就会返回一个error。进程得到返回值后可以做其他事情，然后经过某段时间间隔，再发起`recvform`系统调用，以此重复，当数据准没好时，再拷贝数据到进程，进行数据处理。**需要注意的是，拷贝数据整个过程，进程仍然是阻塞状态。** 大致如下图：

![同步非阻塞IO](https://upload-images.jianshu.io/upload_images/2062729-69746d536c2781da.png?imageMogr2/auto-orient/strip|imageView2/2/w/1168/format/webp)

#### 优点： 可以在等待任务完成时做其他事情。
#### 缺点： 任务响应延迟增大，频繁轮询消耗CPU。

于同步非阻塞方式需要不断主动轮询，轮询占据了很大一部分过程，轮询会消耗大量的CPU时间，而 “后台” 可能有多个任务在同时进行，人们就想到了循环查询多个任务的完成状态，只要有任何一个任务完成，就去处理它。如果轮询不是进程的用户态，而是有人帮忙就好了。那么这就是所谓的 “IO 多路复用”。（也就是Linux中所提供的的select、poll、epoll）

select调用是内核级的，select轮训相对非阻塞的轮训区别在于——前者可以等待多个socket，能实现同时对多个IO端口进行监听，当其中一个socket数据准备好了，就能够返回，然后进程在进行`recvform`系统调用，将数据从内核拷贝到用户进程（*拷贝过程是阻塞的*）。

select和poll调用之后，会阻塞进程，但是与BlockIO阻塞区别在于，此时的select不是等到socket数据全部到达再处理，而是有一部分数据就会调用用户进程来处理。如何知道有一部分数据到达了呢？前面说过，这些方法都是内核级的，内核负责数据到达的处理。

IO复用模型会用到select、poll、epoll函数，这几个函数也会是进程阻塞，但是和BlockIO不同的是这几个函数可以同时阻塞多个IO操作（包括read/write），直到有可读/可写数据时，才会真正调用IO操作函数。

### 多路复用
多路复用其实就是轮询多个socket。多路复用既然可以同时处理多个IO，也就带来了一个新的问题，多个IO之间的顺序问题。具体流程如下图所示：

当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。


![多路复用](https://upload-images.jianshu.io/upload_images/2062729-d552e1e2ca381a08.png?imageMogr2/auto-orient/strip|imageView2/2/w/1128/format/webp)

上面的图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。

所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。（select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）

### 优点
在I/O编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或者I/O多路复用技术进行处理。I/O多路复用技术通过把多个I/O的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型比，I/O多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降底了系统的维护工作量，节省了系统资源。

> ***从整个IO过程来看，他们都是顺序执行的，因此可以归为同步模型(synchronous)。都是进程主动等待且向内核检查状态。***

高并发的程序一般使用同步非阻塞方式而非多线程 + 同步阻塞方式。要理解这一点，首先要扯到并发和并行的区别。比如去某部门办事需要依次去几个窗口，办事大厅里的人数就是并发数，而窗口个数就是并行度。也就是说并发数是指同时进行的任务数（如同时服务的 HTTP 请求），而并行数是可以同时工作的物理资源数量（如 CPU 核数）。通过合理调度任务的不同阶段，并发数可以远远大于并行度，这就是区区几个 CPU 可以支持上万个用户并发请求的奥秘。在这种高并发的情况下，为每个任务（用户请求）创建一个进程或线程的开销非常大。而同步非阻塞方式可以把多个 IO 请求丢到后台去，这就可以在一个进程里服务大量的并发 IO 请求。

那问题来了：*IO多路复用是同步阻塞模型还是异步阻塞模型呢？*
同步是需要主动等待消息通知，而异步则是被动接受消息通知，通过回调、通知、状态等方式来获取消息。IO多路复用在阻塞到select阶段时，用户进程是主动等待并调用select函数获取数据的就绪状态消息，并且其进程状态为阻塞。所以，IO多路复用是**同步阻塞模型**。

### 信号驱动IO模型
收到信号再进行`recvform`的系统调用。如下图：

![信号驱动IO](https://upload-images.jianshu.io/upload_images/2062729-222408c76186fd8c.png?imageMogr2/auto-orient/strip|imageView2/2/w/1192/format/webp)

### 异步非阻塞IO

### 相关文章
[聊聊Linux五种IO模型](https://www.jianshu.com/p/486b0965c296)
