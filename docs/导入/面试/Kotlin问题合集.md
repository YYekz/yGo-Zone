
## 协程

### 有栈协程 与 无栈协程
**Kotlin的协程是一种无栈协程的实现。**

由于协程需要支持挂起、恢复，因此对于挂起点的状态保存就显得极其关键。类似地，线程会因为 CPU 调度权的切换而被中断，它的中断状态会保存在调用栈当中，因而协程的实现也按照是否开辟相应的调用栈存在以下两种类型：

-   有栈协程 Stackful Coroutine：每一个协程都会有自己的调用栈，有点儿类似于线程的调用栈，这种情况下的协程实现其实很大程度上接近线程，主要不同体现在调度上。
-   无栈协程 Stackless Coroutine：协程没有自己的调用栈，挂起点的状态通过状态机或者闭包等语法来实现。

###  挂起和阻塞
**阻塞**：正在执行的进程由于IO操作或网络请求等导致无法继续进行，此时引起进程调度，OS把CPU分配给其他就绪线程，让当前线程处在暂停状态，这种暂停状态称之为阻塞。
**挂起**：用户或者OS主动挂起，如果进程正在执行，将暂停，若原本处于就绪则暂时不接受调度。

**相同点**：进程都会挂起；

### Dispatchers
**Dispatchers.Default**：默认的调度器，适合处理后台计算，是一个`CPU`密集型任务调度器。与IO共享后台线程池，不同是限制了最大并发数不同。
**Dispatchers.IO**：用来执行阻塞 `IO` 操作的，是和`Default`共用一个共享的线程池来执行里面的任务。根据同时运行的任务数量，在需要的时候会创建额外的线程，当任务执行完毕后会释放不需要的线程。
**Dispatchers.Main**：在Android中就是UI线程。
**Dispatchers.Unconfined**：由于`Dispatchers.Unconfined`未定义线程池，所以执行的时候默认在启动线程。遇到第一个挂起点，之后由调用`resume`的线程决定恢复协程的线程。

### CoroutineStart
**CoroutineStart.DEFAULT**：创建后**立即开始调度**，在调度前如果协程被取消则**直接进入取消**相应状态。（虽然是立即调度，但也有可能在执行前被取消）
**CoroutineStart.ATOMIC**：创建后立即开始调度，协程执行到第一个挂起点之前不响应取消。其实就是将调度和执行两个步骤合二为一保证原子操作，因此协程一定会执行。
**CoroutineStart.LAZY**：当对应协程被需要时（主动调用`start`、`join`或者`await`等）函数才会开始调度，如果调度前就被取消，协程将直接进入异常结束状态。
**CoroutineStart.UNDISPATCHED**：协程创建后立即在当前函数调用栈中执行，直到遇到第一个真正挂起的点（一定会执行）
> 业务开发中基本上DEFAULT 和LAZY就足够。


[硬核万字解读：Kotlin 协程原理解析 - 开发者头条](https://toutiao.io/posts/vtq5kjj/preview)
[万字长文 - Kotlin 协程进阶 - 掘金](https://juejin.cn/post/6950616789390721037#heading-4)

