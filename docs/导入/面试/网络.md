
##  三次握手
![[Pasted image 20230328104749.png|300]]
-   半连接队列，也称 SYN 队列；
-   全连接队列，也称 accept 队列；
### 为什么需要三次？两次可以吗？会有什么问题？
1. 可以阻止重复历史连接的初始化（主要原因）；
2. 可以同步双方的初始化序列号；
3. 可以避免资源浪费；

> [4.1 TCP 三次握手与四次挥手面试题 | 小林coding](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E3%80%81%E5%9B%9B%E6%AC%A1)
## 四次分手
![[Pasted image 20230328113127.png|300]]


### 为什么需要四次？三次会有什么问题？


### 最后为什么需要等待2MSL？
> MSL：是报文最大生存时间，是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。
> TTL：是IP数据包可以经过的最大路由数，每经过一个处理他的路由器就减一，当为0时数据包被丢弃，同时发送ICMP报文通知源主机。
> 区别是MSL的单位是时间，TTL的单位是次数，所以MSL应该要大于TTL消耗为0的时间，以确保报文是自然消亡。

**需要一来一回的时间**，也可以说是允许报文丢一次。比如被动关闭方没有收到断开连接的ACK报文，就会触发超时重发，主动方收到后，重发ACK给被东莞比方，需要2个MSL。其实也可以多个MSL，但没有意义，那么设计不具有性价比。

2MSL是从**客户端收到FIN后发送ACK开始计时的**，如果因为重传重新发送FIN报文，那2MSL会重新计时。(Linux中TIME_WAIT时间是60s，所以1MSL是30s)

### 为什么需要TIME_WAIT状态？
**防止历史连接中的数据被后面相同四元组的连接错误接收**。为了我们的数据包不会乱序，TCP头部会有序列号，是一个32位无符号数，因此在达到4G时会循环回0；如果发生回绕，相同数据序列号被下一个连接接收到了就会导致数据错乱，所以2MSL足以让两个方向上的数据包都被丢弃。
**保证被动关闭的一方能被正确的关闭。** 如果客户端在发完最后一次ACK后直接CLOSE，如果ACK丢失了，那么服务端会重传FIN报文，此时客户端已经关闭状态了，收到服务端的重传FIN报文后会回复RST报文。


## 输入网址点下回车后都发生了什么？

HTTP -> DNS -> 协议栈 TCP -> IP -> MAC -> 网卡 -> 交换机 -> 路由器 -> 服务器


## TCP、UDP、IP

### TCP与UDP的区别？
#### TCP的缺点：
1. 升级TCP的工作很困难；
2. TCP建立连接的延迟；
3. TCP存在队头阻塞问题；
4. 网络迁移需要重建TCP连接；

多了很多特性，例如 **流量控制、超时重传、拥塞控制**其实都是为了保证数据包可控的传输给对方。

### IP有哪些功能？

**IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘**。

**寻址**：首先根据子网掩码算出网络号和主机号；
**路由**：两台设备之间会有很多其他网络设备，所以需要知道数据包到达一个网络节点，通过路由算法决定下一步走那条路径。

### IP会分片，为什么TCP还需要MSS呢？
![[Pasted image 20230328110831.png|300]]
其实让IP去分片也没有问题，但问题的关键在于如果有IP片丢失了，这时，需要将整个IP报文重传，IP层本身是没有超时重传机制的，它由传输层的TCP来负责。
如果接收方IP层无法组装成一个完成的TCP报文，就无法将数据报文发送到TCP层，也就无法响应ACK给发送方，就会超时重传整个TCP报文，所以建立连接时候也会协商MSS，防止IP包大于MTU使IP分片。所以即使一个TCP分片丢失，重发时也是以一个MSS为单位，不用重传所有增强重传效率。

### 如何解决粘包？
粘包其实是一种很抽象的说法，本来TCP就是面向流实现的。
一般有三种方式：
**1. 固定包长的数据包**：比如规定64字节，每次满就解析，这种简单但是灵活性差。
**2. 以指定字符串为包结束的标志**：比如FTP协议，邮件的SMTP协议，结束加上`\r\n`也就是所谓的CRLF表示包结束，这种协议一般用在包含各种命令控制的应用中，不足之处就是要对字符串做转码或转义，防止数据被当成错误的结束标志解析。
**3. 包头+包体格式**：例如包头大小固定为4字节，对端先收取包头大小字节，解析包头知道包体大小，等收够了就拿出来处理。

# HTTP

### Cookie 和 Session有什么区别？
**Session**：是在服务端保存的一个数据结构，用来跟踪用户状态，可以保存在数据库、内存、文件、集群中；
**Cookie**：是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现session的一种方式；

HTTP是无状态的，所以服务端需要记录用户的状态操作就需要Session，Session可以存储在很多地方，服务端为了识别对应的客户，会在第一次创建session时，服务端在http协议中告诉客户端（cookie中的seesionId），以后每次http请求都带上这个seesionId即可。（如果仅用了cookie，就会使用url重写技术在url后面品上一个类似sid = xxxx的参数来识别用户）。cookie也可以用来记录个人信息，方便你免登录。


### TCP的KeepAlive 和HTTP的Keep-Alive是一个东西吗？
完全不同。
> HTTP的Keep-Alive是由应用层（用户态）实现的称为HTTP长连接；
> TCP的KeepAlive是由TCP（内核态）实现的称为TCP保活机制；
    
HTTP从1.1开始，就默认开启了Keep-Alive，想要关闭需要在头中加入`Connection:close`。支持keep-alive也为http流水线技术实现提供基础，即客户端可以一次性发多个请求，而在发送过程中无需等待服务器回应，可以减少整体响应时间，服务端还是会按照**顺序响应**，所以如果服务端响应过程发生了阻塞，那客户端就无法发送下一批请求，也就是**队头阻塞**的问题。也可以设置超时，超过就服务端主动断开链接，防止资源浪费。

TCP的keepalive是为了tcp保活而发送探测报文。
- 如果对端是正常的，则对端会正常响应，这样TCP保活时间会被重置，等待下一个TCP保活时间到来；
- 如果对端宕机了，发送探测报文就不可达，连续几次后无响应，TCP就会报告连接死亡。

### GET 和 POST的区别？
> 安全是指不会破坏服务器上的资源，幂等是指多次相同操作，结果一致。

GET是安全幂等的可以被缓存，POST不是安全幂等的（多次提交数据会创建多个资源）。当然这是从RFC的规范语义来说，如果用POST实现查询数据，用GET实现修改数据，当然就反过来了。

### 缓存
![[Pasted image 20230329181922.png|400]]
强制缓存和协商缓存。

#### 强制缓存
HTTP头中`Cache-Control`是相对时间，`Expries`是绝对时间，如果都存在，Cache-Control优先级更高，更加灵活。
当浏览器第一次访问服务器资源，服务器会在Response头加上Cache-Control，设置了过期时间；浏览器再次访问服务其中的该资源时，会先通过请求资源的时间与Cache-Control中设置的过期时间大小，如果没过期直接使用缓存，下次请求会更新Cache-Control。

#### 协商缓存
> 请求返回响应码304是告诉浏览器可以使用本地缓存的资源，这种告知客户端使用缓存的方式是协商缓存。

可以基于两种同步来实现。
**请求头的If-Modified-Since和响应头的Last-Modified**：
Last-Modified标示这个响应资源的最后修改时间；请求头的If-Modified-Since表示 当资源过期了，发现响应头中有Last-Modified，则再次发起请求是带上这个字段，服务器收到后会将两个字段对比，如果最后修改时间新，则返回最新的资源，HTTP200；如果最后修改时间旧，说明资源无修改，那就HTTP304走缓存。
**请求头的If-None-Match和响应头的ETag**：
Etag：唯一标识响应资源；
If-None-Match：资源过期时，浏览器发现响应头中有Etag，则再次向服务器发起请求时，会将请求头的If-None-Match值设置为Etag值，服务器收到后会对比，如果有变化则返回200，无变化则返回304。

第一种实现基于时间，第二种实现基于唯一标识，相对而言后者更准。如果字段都有，则Etag优先级更高，先判断Etag再判断Last-Modified。

##### 为什么Etag优先级更高？
1. 没有修改文件内容情况下文件的修改时间也可能变更，会导致客户端认为文件变动从而重新请求；
2. 有些服务器不能精准获取文件最后修改时间；
3. 可能有些文件是在秒级以内修改的，`If-Modified-Since` 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；

协商缓存这两个字段都需要配合强制缓存中`Cache-Control`字段使用，只能在未命中强制缓存时才能发起带有协商缓存字段的请求。

> [3.1 HTTP 常见面试题 | 小林coding](https://xiaolincoding.com/network/2_http/http_interview.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98)

### HTTP 各版本区别
![[Pasted image 20230329215846.png|400]]
#### HTTP1.1
基于请求-响应模型。
##### 优化
1. 使用长连接改善了HTTP1.0短连接导致的连接性能开销；
2. 支持管道网络传输，无需等待返回结果可以连续发送请求以减少整体的响应时间；
##### 缺陷
1. 请求/响应头部未压缩，头信息越多延迟越大，只压缩body部分，若每次发送相同的首部也会造成资源浪费；
2. 队头阻塞，虽然请求是无需等待响应连续发送的，但服务端需要按照顺序依次响应请求结果，某请求响应耗时长导致后面的请求响应阻塞；
3. 没有请求优先级；
4. 只能从客户端开始，服务端只能被动响应；

##### 如何优化
1. 尽量避免发送HTTP请求 —— 缓存；
2. 在需要发送HTTP请求时，考虑如何减少请求次数 —— 请求合并、减少重定向次数、按需访问（只请求当前用得到、看得到的资源）；
3. 减少服务器的HTTP响应数据大小 —— 数据压缩；

##### 数据压缩
**无损压缩**：请求头Accept-Encoding和响应头Content-Encoding。常见的压缩算法：gzip，br。

**有损压缩**：解压后数据会与原始数据有不同但是非常接近，牺牲一些质量来减少数据量提高压缩比，经常用于压缩多媒体数据，比如音频、视频、图片。
请求头中Accept：audio/* ; q= 0.2  q就是质量因子。

#### HTTP 2
HTTP2是基于HTTPS的，所以安全性也有保证。
##### 优化
1. **头部压缩**，如果发送多个请求他们的头是一样的或者相似的，协议会帮你**消除重复**的部分（HPACK算法，在客户端和服务端同时维护一张**头信息表**，所有的字段都会存入在表中，如果已存在则不发送字段只发送索引号）；
2. **二进制格式**，1.1中使用纯文本形式报文，2.0中头和body都改为二进制格式并称之为帧：头帧和数据帧，虽然对人不友好但是对计算机友好，收到报文后无需转化为二进制，可直接进行解析增加了数据传输的效率；
3. **并发传输**，HTTP2引入Stream概念，多Stream服用一条TCP连接。不同HTTP请求用独一无二的StreamId区分，接收端可以通过StreamId有序组装HTTP消息，不同的Stream帧可以乱序发送、并发发送，以消除HTTP1.1中队头阻塞；
4. **服务器主动推送资源**，客户端和服务器都可以建立Stream，客户端建立的Stream必须是奇数，服务端必须是偶数，服务端可以主动推送减少了消息传递的次数。
##### 缺陷
**TCP的队头阻塞**。HTTP2解决了HTTP1.1中的服务端响应的队头阻塞问题，但HTTP2是基于TCP协议来传输的，TCP是字节流协议，TCP层必须保证收到的字节数完整且连续这样内核才会讲缓冲区的数据返回给HTTP应用，所以当前一个请求数据没有完整到达时，后收到的请求数据只能存放在内核缓冲区中，只有等前一个数据完整到达时，HTTP2应用层才能拿到内核缓冲区的数据。（所以一旦发生了丢包就会触发TCP的重传机制，后面的所有HTTP请求都要等这个丢失的包重传）
TCP的队头阻塞是因为**接收窗口的队头阻塞问题**。接收窗口收到有序数据时窗口才能滑动，然后那些有序并且已经接收确认有序的数据就可以被应用层读取。但是有一个字节的数据没到，后面所有字节数据都到了这些数据也无法被应用层读取，只有缺失字节重传到达后窗口才会继续滑动。
虽然HTTP2支持并发传输，不同Stream的帧是可以乱序发送，每个帧的头部都带有StreamID，所以可以通过StreamID有序组装成HTTP消息。**但是，HTTP2的这些乱序Stream始终还是在一条TCP连接上传输的，意味着多个stream公用同一个tcp滑动窗口，那么当发生数据发生丢包时，窗口还是无法移动的，这时候也就会造成TCP层的队头阻塞。** 

##### HPACK

HTTP/2 没使用常见的 gzip 压缩方式来压缩头部，而是开发了 **HPACK** 算法，HPACK 算法主要包含三个组成部分：
-   静态字典；
-   动态字典；
-   Huffman 编码（压缩算法）；
客户端和服务器两端都会建立和维护「**字典**」，用长度较小的索引号表示重复的字符串，再用 Huffman 编码压缩数据，**可达到 50%~90% 的高压缩率**。
#### HTTP3
##### 优化
1. **无队头阻塞**。为了解决TCP导致的队头阻塞，HTTP3基于UDP协议，UDP不可靠，所以使用基于UDP的QUIC协议实现类似TCP的可靠传输。在QUIC连接上的多个Stream之间并没有依赖关系，当某个Stream发生丢包时，只会阻塞这个流，其他流不会受到影响，所以不存在队头阻塞；。
2. **更快的连接建立**。在HTTP1和HTTP2协议中，TCP和TLS是分层的，TCP在传输层，openssl在表现层无法合并在一起需要分批次来握手，先TCP连接三次握手，再TLS握手。TLS1.3只需要一个RTT即可完成握手（1.2需要两个），而且HTTP3中 **QUIC协议和TLS并不分层，QUIC包含在TLS**，它在自己的帧会携带TLS里的记录，因此在第一次时，甚至仅需要1个RTT就可以同时完成建连与密钥协商；第二次甚至可以将数据包和QUIC握手信息（连接信息+TLS信息）一起发送，达到0RTT；
3. **连接迁移**。HTTP通过四元组（源IP、源端口、目标IP、目标端口）确定一条TCP连接，那么当移动设备发生网络切换4G到wifi，意味着IP地址发生变更，那就要断开连接，重新建连，这个过程会给用户网络卡顿了一下的效果，迁移成本高。而QUIC协议没有通过四元组来绑定连接，而是通过连接ID来标记两个端点，服务端和客户端各自选择一组ID来标示自己，当网络状态变更IP地址变化时只要有上下文（连接ID、TLS密钥等）就可以无缝复用原连接，消除重连成本，达到连接迁移效果； ^5121d3

> 所以QUIC其实是一个在UDP之上的伪TCP + TLS + HTTP2的多路复用协议。

但目前很多设备并不支持QUIC，所以会将QUIC当做UDP包导致丢弃。

### 基于UDP怎么实现可靠传输？
google QUIC
#### QUIC实现可靠传输
![[Pasted image 20230331000547.png|300]]
增加头的细节。Packet Header 细分这两种：Long Packet Header 用于**首次建立连接**和Short Packet Header 用于**日常传输数据**。QUIC也需要三次握手建立，主要是为了协商连接ID。连接ID确认后就可以实现连接迁移功能。ShortPacketHeader中的PackageNumber是每个报文独一无二的编号（严格递增），即使某个报文丢失了，重传报文也不再是N，而是一个大于N的值。
1. 这样设计可以**更加精准的计算出报文RTT，没有歧义性**。
2. 更重要的好处是，**单调递增可以让数据包无需像TCP一样有序确认，可以支持乱序确认，方便窗口滑动不会阻塞后面已到达数据包**。那如果丢包重传是怎么确认的呢？
**QUIC 通过单向递增的 Packet Number，配合 Stream ID 与 Offset 字段信息，可以支持乱序确认而不影响数据包的正确组装**，摆脱了TCP 必须按顺序确认应答 ACK 的限制，解决了 TCP 因某个数据包重传而阻塞后续所有待发送数据包的问题。

#### QUIC解决队头阻塞
[[#^73aaef]]
QUIC 也借鉴 HTTP/2 里的 Stream 的概念，在一条 QUIC 连接上可以并发发送多个 HTTP 请求 (Stream)。但是 **QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 Stream 之间没有依赖关系，都是相互独立的，各自控制的滑动窗口**。

[4.17 如何基于 UDP 协议实现可靠传输？ | 小林coding](https://xiaolincoding.com/network/3_tcp/quic.html#quic-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84)

#### QUIC 更快的连接建立
![[Pasted image 20230331001420.png|400]]
**QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果**。

#### QUIC 是如何迁移连接的？
[[#^5121d3]]
### HTTPS

#### TLS/SSL 握手过程
>TLS和SSL基本算是一个东西，TLS基于SSL发展而来。SSL和TLS都是用于保护网络通信安全的协议，TLS比SSL更加安全，已经成为主流的网络加密协议。

TLS的握手过程每一个操作的基本单位是*记录record*(类似于TCP里的segment)，多个记录可以组合成一个tcp包发送，通常经过**四个消息**就可以完成TLS握手也就是2个RTT时延，接下来就可以在安全的环境里发送HTTP报文。

所以可以看出HTTPS是应用层协议，先建立TCP连接再TLS握手后才能建立安全可行的连接。不同密钥交换算法TLS的握手过程会有一些区别。

密钥加密算法考虑到性能问题，所以应用信息使用对称加密密钥加密，而对称加密的密钥不能泄露，所以使用非对称加密密钥来加密对称加密密钥以保证安全性。最简单的RSA密钥交换算法看看TLS握手的过程。

##### RSA握手

TLS证书部署在服务器，证书其实就是服务器的公钥，会在握手阶段传递给客户端，私钥服务器会保留在服务端。在RSA秘钥协商算法中，客户端会生成随机秘钥，使用服务端公钥加密后再传给服务端，服务端使用私钥解密这样双方就拥有相同的秘钥，可以加密通信。
![[Pasted image 20230330141029.png|400]]

1. 第一次握手，客户端发送Client Hello包含：TLS版本，随机数（ClientRandom）以及支持的密码套件列表；
2. 第二次握手，服务端收到客户端的消息后，确认TLS版本号是否支持，从密码套件列表中选出一个密码套件，以及生成随机数（ServerRandom）；
3. 服务端为了证明自己的身份，将证书（Server Certificate）发送给客户端，里面包含数字证书；
4. 服务端发送Server Hello Done 消息，告诉客户端打招呼结束；
5. 客户端拿到数字证书后需要校验数字证书真实性；
6. 第三次握手，客户端会生成一个新随机数（pre-master），用服务端的RSA公钥加密该随机数，通过Client Key Exchange消息传给服务端；至此，客户端和服务端双方都享有三个随机数，Client Random、Server Random、pre-master。根据三个随机数生成会话对称密钥，用于后续HTTP请求/响应的数据加密解密；
7. 生成完会话秘钥后，客户端发送一个Change Cipher Spec高速服务端开始使用加密方式发消息；
8. 客户端在发送一个摘要消息，把之前所有的数据做摘要，用会话密钥加密让服务端做个验证，确认加密通信是否可信以及之前握手信息是否有被篡改过；
9. 第四次握手，同样发送Change Cipher Spec和摘要消息验证是否可行，如果没问题握手完成。

##### 客户端验证证书
![[Pasted image 20230330163104.png|400]]

CA 签发证书的过程，如上图左边部分：
-   首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；
-   然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；
-   最后将 Certificate Signature 添加在文件证书上，形成数字证书；

客户端校验服务端的数字证书的过程，如上图右边部分：
-   首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；
-   通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；
-   最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。

**RSA 和 ECDHE 握手过程的区别**：RSA 密钥协商算法「不支持」前向保密，ECDHE 密钥协商算法「支持」前向保密，可以不用等服务端最后一次TLS握手，就可以提前发送加密数据，节省了一个RTT。

### HTTP和RPC有什么区别？
> RPC：Remote Procedure Call，远程过程调用。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，**不一定非得基于 TCP 协议**。

**RPC 本质上不算是协议，而是一种调用方式**，而像 gRPC 和 Thrift 这样的具体实现，才是协议。从发展历史来说，**HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合**。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP/1.1 **性能**要更好，所以大部分公司内部都还在使用 RPC。但HTTP2.0在HTTP1.1上优化后，性能可能比很多RPC协议都要好。

### HTTP和WebSocket的关系？
-   TCP 协议本身是**全双工**的，但我们最常用的 HTTP/1.1，虽然是基于 TCP 的协议，但它是**半双工**的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的 WebSocket 协议。
- 在 HTTP/1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用**定时轮询或者长轮询**的方式实现**服务器推送**(comet)的效果。
-   对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 WebSocket 协议。
-   WebSocket 和 socket 几乎没有任何关系，只是叫法相似。
-   正因为各个浏览器都支持 HTTP协议，所以 WebSocket 会先利用HTTP协议加上一些特殊的 header 头(Upgrade:websocket HTTP状态码=101，指协议切换)进行握手升级(随机生成的base64相互发送验证)操作，升级成功后就跟 HTTP 没有任何关系了，之后就用 WebSocket 的数据格式进行收发数据。

### HTTP和MQTT有什么区别？

#### MQTT
1. 基于TCP长连接的应用层协议；
2. 基于C/S架构；
3. 使用订阅/发布模式，将消息的发送方和接收方解耦；
4. 提供三种推送模式；
5. 收发消息都是异步的，发送方不需要等待接收方应答；

##### MQTT协议格式
使用二进制数据包，三个部分分别是：固定头、可变头、消息体；
**固定头**存在所有的MQTT数据包中，长度是2-5字节，包括三部分内容，数据包类型（4bit）、标识位（4bit），数据包剩余长度大小1-4byte。
**可变头**和**消息体**是部分MQTT数据包含。
MQTT协议中，固定头中的数据包剩余长度大小包括可变头和消息体长度，剩余长度可用1~4Byte表示，4Byte最大可表示256MB（0xFFFFFF7F）。有些数据包没有可变头和消息体。
- 最大值：256MB+5Byte，其中256MB是剩余长度最大值，包括可变头和消息体；5Byte是固定头，数据包类型（4bit），标识位（4bit），数据包剩余长度大小（4Byte）；
- 最小值：2Byte，比如PINGREQ数据包，只有固定头，没有可变头，消息体；


##### 发布/订阅
MQTT是通过发布/订阅模式实现，由于发布方和订阅方没有直接联系，所以需要一个中间方对消息进行发布和存储，我们称这个中间方为Broker，Broker 简单来说就是基于mqtt协议的server实现（github 上有很多开源实现），连接到Broker的发布方和订阅方作为Client；
1. 发布方和订阅方都建立了到Broker的TCP连接；
2. 订阅方告知Broker它要订阅的Topic；
3. 发布方将消息发送到Broker，并指定消息主题（Topic）；
4. Broker接收到消息后，检测哪些订阅方订阅了对应的Topic，然后将消息发送到订阅方；
5. 订阅方从Broker获取消息；
6. 如果某个订阅方处于离线状态，Broker可以先保存对应的消息，当订阅方下次连接到Broker的时候，再将之前的消息发送给订阅方；

MQTT有三种推送类别：
1. QoS0：最多到达一次。（发出去之后无需等待ack）
2. QoS1：至少一次到达。（发出去之后必须等待ack，超时重发）
3. QoS2：准确到达一次。（消息id有一个简单的生命周期，即使是这样，仍然是存在重发投递的，只是风险小了很多而已。这里出现重复投递的地方，就是在pubrel之后，投递给上层的时候出现的。但是因为是本地投递，出现问题的概率，相对低很多。）
![[Pasted image 20230331155822.png|300]]

##### 实现过程

**建立连接**：Client在发布和订阅消息前先链接Broker，这个连接不仅仅是建立TCP连接，还有应用层建立连接，MQTT建立连接：
1. Client向Broker发送CONNECT数据包；
2. Broker收到后，允许接入回复返回码0的CONNACK数据包；如果拒绝接入，回复非0的CONNACK数据包，返回码代表错误原因；

**关闭连接**：关闭分三种情况：Client主动发起、Server主动发起、心跳超时。
1. **Client主动发起**：Client向Broker发送DISCONNECT数据包不用等待回复（Broker不会回复），发完就可以关闭底层TCP连接；之所以不需要和Broker有交互数据包是因为让Broker识别是正常的断开，Broker会丢弃遗愿；
2. **Broker主动发起**：不需要发送任何MQTT数据包，直接关闭底层TCP连接；
3. **keepalive超时**：MQTT协议规定Broker没有收到Client的DISCONNECT数据包之前应该都保持连接，但是如果Broker在keepalive时间间隔里都没有收到Client的任何数据包就会主动关闭（keepalive数值可以在Client发起时数据包中指定）。

**那MQTT如何保活呢？keepalive的作用。**
因为TCP协议有个半打开的状态，一般这种情况下TCp连接一端已失效，但另一端并不知。为了解决这种情况MQTT设计了一套keepalive机制，约定在1.5* keepalive时间间隔内，如果没收到任何来自Client的包就断开连接，如果Client没有收到任何来自Broker的包也会断开连接。MQTT协议设计了一对**PINGREQ/PINGRESP**数据包，当之间没有数据交互时，就可以通过这对数据包满足keepalive的约定和网络状态检测（keepalive位0时代表不使用keepalive机制）。

**发布、订阅**：
1. 支持接受离线消息：Broker会保存发布的消息，在上线后推送给Client（但QoS要非0）；
2. 主题通配符：可以使用通配符订阅主题；

