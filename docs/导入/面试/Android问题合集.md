### Art虚拟机和Dalvik虚拟机的区别？
安卓5.0之前的虚拟机是Dalvik虚拟机，使用的是JIT编译，即每次运行程序，都实时地进行将部分dex字节码编译成机器指令供手机去运行，这样整个apk包占用系统内存会很小，但因为每次运行都需要编译，所以CPU的消耗则变大。
5.0之后安卓虚拟机就变成ART虚拟机，使用AOT编译，即在应用安装期间，就将全部dex文件编译成机器指令存储在手机上。这样手机运行app时就可以直接运行这些机器指令，不需要像以前Dalvik虚拟机那样还要再去编译，这样就可以使得整个app运行过程速度要快很多。当然与此同时app可能会比以前要占用的内存要大，但现在的安卓手机的内存已经发展的越来越大了，所以这个缺点是可以忽略不计的。

### Android虚拟机和Java虚拟机的区别？

寄存器是相当于CPU里的内存，而它是有固定的内存地址的，所以数据在它那里存取是非常快的，距离CPU又近，所以直接根据它的内存地址便可取到数据。
寄存器的指令长度较长，但一个指令能存储的数据也多，但也容易丢失，但总体来看，可以用数量更少的指令去完成操作。而栈的指令则跟寄存器的情况相反，指令短小，携带数据也变少，但能快速执行。
要补充的一点就是**Android虚拟机是基于寄存器的虚拟机，而jvm虚拟机是基于虚拟栈的虚拟机**。所以dex文件里的指令跟class文件里的指令相比，dex指令要长而且数量要少，这也是dex文件与class文件的**区别**。

### .so 与 jar 的区别？
**.so文件**：是Linux系统的可执行文件，相当于windows的.exe文件，只能在Linux上运行。就是我们常说的动态链接库，是C/C++编译出来的。
**jar文件**：Java Archive File，静态库。是java一种文档格式，非常类似Zip文件，和Zip的唯一区别就是在jar文件包中，包含了一个`META-INF/MANIFEST.MF`文件，这个文件是生成jar文件时自动创建的。

所以区别其实是**动态库和静态库的区别：**
1. **存在周期**：.so是动态库，而jar文件是静态库文件；静态库在程序编译时会被连接到目标代码中，程序运行时将不在需要；而动态库在编译时并不会被连接到目标代码中，而是在程序运行时被载入，因此程序运行时还需要动态库存在；
2. 使用静态函数库体积会比较大， 因为整个函数库的所有数据都会被整合进目标代码中，
	1. 优点：编译后的执行程序不再需要外部函数库的支持，使用的所有函数都已经被编译进去了；
	2. 缺点：如果静态函数库改动了，那你的程序需要重新编译；
3. 使用动态函数库，并不会在编译期直接被编译进目标代码中，而是程序执行时调用，因此使用动态函数库所产生的可执行文件小一些，由于是运行期间动态申请并调用的，所以程序运行环境中需要提供对应的库。
	1. 优点：动态函数库的改变不影响你的程序，无需重新编译；

> [jar文件和.so文件的区别\_acMiner的博客-CSDN博客\_jar 文件与 so文件](https://blog.csdn.net/acMiner/article/details/73650411)

### jar 和 dex区别
jar是多个.class文件打包而成的二进制归档文件包，而dex是直接将.class文件优化打包后的文件，dalvik虚拟机是.dex可执行文件。
> dex2jar 和 dx 可以将jar和dex相互转化

![[Pasted image 20230208171019.png|300]]

### Serializable 和 Parcelable

序列化的原因基本可以归纳为以下三种情况：
-   永久性保存对象，保存对象的字节序列到本地文件中
-   通过序列化对象在网络中传递
-   通过序列化对象在进程间传递

Serializable使用**IO读写**存储在硬盘上，而Parcelable是直接在**内存中读写**（内存读写速度大于IO读写）。而且Serializable会使用到反射，创建大量对象（GC频繁），序列化和反序列化过程需要大量的IO操作，而Parcelable自已实现封送和解封（marshalled &unmarshalled）操作不需要用反射，数据也存放在 Native 内存中，效率要快很多。
但Parcelable不能使用在要将数据存储在磁盘上的情况，因为Parcelable不能很好的保证数据的持久性在外界有变化的情况下，尽管Serializable效率低点，但此时还是建议使用Serializable

> [android中的序列化机制原理 | 苏富仕的博客](https://sufushi.github.io/2018/01/24/android%E4%B8%AD%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86/#Parcel%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0)
> [Serializable 都这么牛逼了，Parcelable，我还要你何用？ - 掘金](https://juejin.cn/post/6844903518826921991#heading-3)


### view真的不能在子线程中使用吗？
[基于dialog///的分析](https://mp.weixin.qq.com/s/tg96p50alrqAtRih8a3AhA)

### 一个App有多少个Application？
[一个app到底会创建多少个Application对象 - 掘金](https://juejin.cn/post/7208345469658415159)

### drawable 和 mipmap有什么区别？
1. 当应用构建为.apk的情况下，drawable和mipmap文件夹下的资源表现无差异，无论是应用内表现还是在应用图标的表现。
2. 当应用构建为.aab的情况下， drawable文件夹下的资源会寻找匹配的设备密度保留，不匹配的资源会被删除以保证apk的大小，而mipmap文件夹下的资源文件会全部保留。
[Android中drawable和mipmap到底有什么区别 - 掘金](https://juejin.cn/post/7179187950050082873)

### 反射
[java反射全解 - 掘金](https://juejin.cn/post/6844903905483030536)
[大白话说Java反射：入门、使用、原理 - 陈树义 - 博客园](https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html)


[[优化相关]]

会议主题：安卓杨蕴琪面试
会议时间：2023/05/18 19:30-20:30
会议链接：https://work.weixin.qq.com/webapp/tm/kS8rF0LaXt2
#会议号：237-982-488