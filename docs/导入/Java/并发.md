并发三要素：可见性、原子性、有序性

### 可见性：CPU缓存引起
因为CPU中有高速缓存，所以读写数据时，可能出现于主存不一致的情况。
**解决方案**：CPU有独立高速缓存，但无法和其他CPU及时同步数据导致的，那只要保证读写数据都和主存一致即可，可以通过*volatile*。当然*synchronized*和*Lock*也可以实现，因为同一时刻只有一个线程持有锁执行代码，并且在释放锁之后也会对变量的修改操作立即刷新到主存中。

### 原子性：分时复用引起
原子性是指一个操作或者多个操作要么全部都执行且过程不会被打断，要么就都不执行，主要还是要“全部一起”。
但CPU时间片切换可能导致多个应该连续操作被拆开导致出现问题。（经典例子：i++）
**解决方案**：既然要保证全部一起，但JMM又只提供基本读写是原子操作，那如果想实现更大范围性的原子性，只要保证**任一时刻**只有**单个线程**执行这段逻辑即可，可以通过*synchronized*和*Lock*来实现。

### 有序性：重排序引起
程序执行是，并不一定是按照我们代码编写顺序执行的，可能会进行优化。
```java
int a=0; //1 
boolean b = false; //2
a = 2; //3
b = true; //4
```
代码并不能保证3一定在4之前执行，这就是指令重排序。

在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：
#### 编译器优化的重排序
编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都需要禁止）。
#### 指令级并行的重排序
现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
#### 内存系统的重排序
由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

指令级并行的重排序 和 内存系统的重排序都算是处理器重排序，JMM处理器重排序会要求java编译器生成指令序列时，插入特定类型的内存屏障指令来禁止特定类型的处理器重排序（同样不是所有处理器重排序都要禁止）。
解决方案：防止重排序可以使用*volatile*来保证一定情况下的有序，*synchronized*和*Lock*保证任一时刻只有一个线程在执行代码，相当于单线程，也就自然保证了有序性。当然JMM是通过HB规则来保证有序性的。

### 总结
其实，所有的并发同步问题，都是由多线程引起的（当然这是句废话），所以只要保证任一时间下，只有一个线程在执行某段代码，就可以保证这段代码可见性、有序性和原子性，也就是说没有并发问题，所以锁（*synchronized*和*Lock*）是终极解，但不是最优解，所以才会有其他方式。

从上面可以看出 想解决的问题主要就是 **禁止缓存** 以及 **编译优化**的方法。其实就是：
1. volatile
2. synchronized
3. final
4. Happens-Before 规则

## Happens-Before 规则
1. 单一线程原则：在一个线程内，程序前面的操作先发生于后面的操作；
2. 管程锁定规则：一个unlock操作先发生于后面对同一个锁的lock操作；
3. volatile变量规则：对于一个volatile变量的写操作先发生于后面对这个变量的读操作；
4. 线程启动规则：Thread对象的start方法调用先于发生于此线程中的每一个动作；
5. 线程加入规则：Thread对象的结束先发生于join方法返回；
6. 线程中断规则：对线程interrupt方法的调用先发生于被中断线程的代码检测到中断事件的发生，可以通过interrupted方法检测是否有中断发生；
7. 对象终结规则：一个对象的初始化完成（构造函数执行完毕）先行发生于它的finalize方法的开始；
8. 传递性：如果操作A先发生于操作B，操作B先发生于操作C，那么操作A先发生于操作C；

## 如何保证线程安全
### 互斥同步
**阻塞同步**，互斥同步是**悲观**的并发策略，无论是否真的会出现竞争，都会加锁（概念模型是这样，但虚拟机会优化掉很大一部分不必要的锁）。

**关键词**：*synchronized* 和 *ReentrantLock*。

### CAS
**非阻塞同步**，随着硬件指令集的发展，更倾向于使用基于冲突检测的**乐观**并发策略：先进行操作，如果没有其他线程竞争共享数据，则操作成功，若有，则不断地重试，直到成功为止。
但乐观锁需要操作和冲突检测这两个步骤具备原子性，是依靠硬件来完成的。硬件支持的原子性操作是：比较并交换（compare and swap，CAS）。
对应使用的类：*Unsafe*以及JUC包里面的AtomicInteger其中的*compareAndSet* 以及 *getAndIncrement*。

#### ABA问题
如果一个变量初次读取是A，被改成了B，后来又被改成了A，那CAS操作会误认为没有发生过改变。
**解决方案**：增加版本号（操作号），JUC包中有一个代表及的原子引用类*AtomicStampedReference*。如果真的需要解决ABA问题，改用传统的互斥同步可能比原子类效率更高。

**关键词**：CAS、UnSafe

其实要保证线程安全，并不一定要进行同步。如果一个数据本身就是私有的，那就无需任何额外操作即可保证正确性。

### 栈封闭
局部变量保存在虚拟机栈中，属于线程私有，就不会出现线程安全问题了。

### 线程本地存储
如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。

**关键词**：[[ThreadLocal]]

### 可重入代码


## 关键字
### Volatile
1. 防止重排序；
2. 可见性；
3. 保证原子性：volatile不能完全保证原子性，只能保证单次的内存操作（读、写）具有原子性。（经典例子：i++，可以使用AtomicInteger）
#### 防止重排序实现原理
为了实现 volatile 内存语义时，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。
对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM 采取了保守的策略。
在每个volatile写操作的前后分别插入：StoreStore和StoreLoad内存屏障；在每个volatile读操作的后面插入：LoadLoad和LoadStore两个内存屏障。
| 内存屏障   | 说明                                                    |
| ---------- | ------------------------------------------------------- |
| StoreStore | 禁止上面的普通写和volatile写重排序                      |
| StoreLoad  | 禁止上面的volatile写于下面可能有的volatile 读、写重排序 |
| LoadLoad   | 禁止下面所有普通读和上面volatile读重排序              |
| LoadStore  | 禁止下面所有的普通写和上面的volatile读重排序                                                        |


#### 可见性实现原理

内存屏障，是一个 CPU 指令。 在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止+ 特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。

对应屏障生成CPU指令时会增加lock前缀，会将当前处理器缓存行的数据写回到系统内存，为了保证各处理器缓存一致，实现了缓存一致性协议（MESI），其他处理器会将当前缓存行设置为无效，当需要对这个数据操作时，会从内存中重新读取变量数据以获得最新值。

#### 有序性实现原理
happens-before中有一条规定：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。

### final

#### 写final域重排序规则
写final域的重排序规则**禁止对final域的写重排序到构造函数之外**。编译器会在final域写之后，构造函数return之前，插入一个**STORESTORE**屏障，可以禁止处理器把final域的写重排序到构造函数之外。

#### 读FINAL域重排序规则
在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序。处理器会在读final域操作的前面插入一个LoadLoad屏障。
> 实际上，读对象的引用和读该对象的final域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。

读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读这个包含这个final域的对象的引用。
#### 为什么final引用不能从构造函数中“溢出”？
对final域写重排序规则可以确保我们在使用一个对象引用的时候该对象的final域已经在构造函数被初始化过了。但是这里其实是有一个前提条件的，也就是：在构造函数，不能让这个被构造的对象被其他线程可见，也就是说该对象引用不能在构造函数中“溢出”。
```java
public class FinalReferenceEscapeDemo { 
private final int a; private FinalReferenceEscapeDemo referenceDemo; 
public FinalReferenceEscapeDemo() { 
a = 1; //1 
referenceDemo = this; //2 
} 

public void writer() { 
new FinalReferenceEscapeDemo(); 
} 

public void reader() { 
if (referenceDemo != null) { //3 
int temp = referenceDemo.a; //4 
		} 
	} 
}
```
尽管依然满足了final域写重排序规则：在引用对象对所有线程可见时，其final域已经完全初始化成功。但是，引用对象“this”逸出，该代码依然存在线程安全的问题。

## 参考链接
[Java 并发 - 理论基础 | Java 全栈知识体系](https://pdai.tech/md/java/thread/java-thread-x-theorty.html)
[关键字: volatile详解 | Java 全栈知识体系](https://pdai.tech/md/java/thread/java-thread-x-key-volatile.html)
[关键字: final详解 | Java 全栈知识体系](https://pdai.tech/md/java/thread/java-thread-x-key-final.html)