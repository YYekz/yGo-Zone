![[Pasted image 20230210215236.png|700]]

## 概念

### 乐观锁与悲观锁
#### 乐观锁
对于同一个数据的并发操作，乐观锁认为自己在使用时不会有别的线程来修改数据，所以不会加锁，只是在更新数据的时候去判断之前是否有其他线程更新了这个数据。如果这个数据没有被更新则直接将自己修改的数据写入；如果被其他线程更新，则根据不同的实现方式执行不同的操作（报错或者自动重试）。
关键字：CAS自旋。

#### 悲观锁
对于同一个数据的并发操作，悲观锁认为在自己使用输的时候一定有别的线程来修改数据，因此会在获取数据之前先加锁，确保数据不会被别的线程修改。
关键字：Lock、synchronized。

#### 总结
悲观锁适合写操作多的场景，先加锁保证写操作数据的正确。
乐观锁适合读操作多的场景，不加所得特点能使读操作的并发性能大幅提升。

### 自旋锁和适应性自旋锁
为什么会出现自旋锁呢？因为当我们阻塞或者唤醒一个Java线程时，是需要操作系统切换CPU状态来完成的，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，可能状态转换消耗的时间比用户代码执行时间都长，这样得不偿失，如果有多个线程同时并行执行，可以让后面请求锁的线程不放弃CPU执行时间，自旋看看持有锁的线程是否会很快释放锁。
但自旋锁本身是有局限性的，它并不能代替阻塞。自旋虽然避免了线程切换的开销，但是他还是要持续占用处理器时间。所以自旋锁适用于所被占用时间较短
的情况，如果所被占用时间过长，那么自旋锁只会白白浪费处理器资源。（所以自旋锁一般有限制次数，默认是10次，没有成功获得锁，就挂起线程）
关键字：CAS、Unsafe自增、synchronized。

### 无锁、偏向锁、轻量级锁、重量级锁
这四种锁状态是专门针对*synchronized*的，锁升级的过程。

### 公平锁、非公平锁
#### 公平锁
公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。

#### 非公平锁
非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。

#### 对比
在公平锁中，当持有锁的线程执行完毕后，会释放锁，CPU唤醒下一个线程。但非公平锁在插队成功的情况下，插队线程可以直接获取锁，没有进入等待队列也不会阻塞，CPU也不需要增加唤醒工作，吞吐量提高。当插队失败后和公平锁一样，需要进入等待队列并阻塞，CPU需要增加唤醒国祚，此时的吞吐量等同于公平锁。

### 独享锁（排它锁）、共享锁
#### 独享锁
独享锁也叫排它锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。
**关键字**：*synchronized*和*Lock*

#### 共享锁
指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。
**关键字**：*ReentrantReadWriteLock*

### 可重入锁（递归锁）
又名**递归锁**，是指在同一个线程在外层方法获取锁的时候，再次进入该线程的内层方法会自动获取锁（前提锁对象是同一个对象或者class），不会因为之前已经获取过没释放而阻塞。



**互斥锁**：


**什么是CAS?**
 即比较并替换，实现并发算法时常用到的一种技术。CAS操作包含三个操作数——内存位置、预期原值及新值。执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。我们都知道，CAS是一条CPU的原子指令（cmpxchg指令），不会造成所谓的数据不一致问题，Unsafe提供的CAS方法（如compareAndSwapXXX）底层实现即为CPU指令cmpxchg。

### 锁膨胀
无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁 
> 锁可以升级但是不可以降级

## 具体
### CAS


### Synchronized
#### monitorenter 与 monitorexit
依赖底层操作系统的Mutex Lock实现，需要将当前线程挂起并从用户态切换到内核态，所以切换代价非常昂贵，大多数同步方法是运行在单线程环境下的，如果每次都调用将会很影响程序响应性能。（jdk1.6引入了优化）

`Monitorenter`和`Monitorexit`指令，会让对象在执行，使其锁计数器加1或者减1。每一个对象在同一时间只与一个monitor(锁)相关联，而一个monitor在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的Monitor锁的所有权的时候，monitorenter指令会发生如下3中情况之一：
-   monitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待
-   如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加
-   这把锁已经被别的线程获取了，等待锁释放

`monitorexit指令`：释放对于monitor的所有权，释放过程很简单，就是讲monitor的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该monitor的所有权，即释放锁。

**问题是**：在JVM中monitorenter和monitorexit字节码依赖于底层的操作系统的**Mutex Lock**来实现的，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的。在现实大部分情况下，同步方法是运行在单线程环境（无锁竞争环境），如果每次都调用Mutex Lock那么将严重影响性能。所以在jdk1.6中引入了大量优化。

#### 锁优化

**锁粗化**：也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。

**锁消除**：JVM在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。如果JVM判断一段同步代码中明显不会逃逸出去被其他线程访问到，那JVM就把他们当做栈上数据对待，认为是线程独有的，无需同步。

**轻量级锁**：在大多数程序开发中，绝大部分同步代码一般都处在*无所竞争状态*。在无锁竞争的情况下，完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是一条CAS原子指令即可完成锁的获取或者释放，执行CAS指令失败的线程将调用操作系统互斥锁进入阻塞状态，当锁被释放时唤醒。

**偏向锁**：在无所竞争的情况下避免在锁获取过程中执行不必要的CAS原子指令。（虽然CAS原子指令相对于重量级锁来说开销很小，但还是会存在影响）
偏向锁的撤销

**自旋锁**：当前线程在获取轻量级锁过程中执行CAS操作失败，在进入重量级锁之前会尝试一定次数的再次获取，如果依然失败，在进入阻塞状态。因为自旋锁在自旋过程中会占用CPU时间片，如果占用时间过长，那么就会白白消耗CPU，所以自旋锁等待时间要有一定的限度。（JDK默认10次）

**自适应自旋锁**：JDK1.6引入。等待时间不是固定的了，是由前一次在同一个锁上的自选时间以及锁拥有者的状态来决定。如果在同一个锁对象上，自选等待刚刚成功获取过锁，并且持有锁的线程正在运行，那么JVM就认为该锁自选获取到的可能性很大，会增加等待时间。反之，对于某个所，自旋很少获取成功锁，那么以后获取这个锁的时候可能直接省略掉自旋的过程，以避免浪费处理器资源。

![[Pasted image 20230212160240.png]]

![[Pasted image 20230212160447.png]]

### Synchronized与Lock
### synchronized的缺陷
-   `效率低`：锁的释放情况少，只有代码执行完毕或者异常结束才会释放锁；试图获取锁的时候不能设定超时，不能中断一个正在使用锁的线程，相对而言，Lock可以中断和设置超时
-   `不够灵活`：加锁和释放的时机单一，每个锁仅有一个单一的条件(某个对象)，相对而言，读写锁更加灵活
-   `无法知道是否成功获得锁`，相对而言，Lock可以拿到状态，如果成功获取锁，....，如果获取失败，.....

### AQS
[JUC锁: 锁核心类AQS详解 | Java 全栈知识体系](https://pdai.tech/md/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html)
#### AQS
AbstractQueuedSynchronizer类底层的数据结构是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点(Node)来实现锁的分配。其中Sync queue，即同步队列，是双向链表，包括head结点和tail结点，head结点主要用作后续的调度。而Condition queue不是必须的，其是一个单向链表，只有当使用Condition时，才会存在此单向链表。并且可能会有多个Condition queue。

#### Condition
Condition为接口类型，它将 Object 监视器方法(wait、notify 和 notifyAll)分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set (wait-set)。其中，Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法的使用。可以通过await(),signal()来休眠/唤醒线程。

### ReentantLock

ReentrantLock类内部总共存在Sync、NonfairSync、FairSync三个类，NonfairSync与FairSync类继承自Sync类，Sync类继承自AbstractQueuedSynchronizer抽象类。

ReentrantLock默认为**NonfairSync**。

NonfairSync与FairSync的主要区别就是在于：当获取锁时，FairSync会去判断当前队列里是否还有等待时间更久的线程，优势就是防止饿死线程，缺点就是性能不高。

说到底还是AQS里的能力，不管是Sync、NonfairSync还是FairSync都是对AQS能力的丰富和使用。


### LockSupport
-   park函数，阻塞线程，并且该线程在下列情况发生之前都会被阻塞:
	- 1.  调用unpark函数，释放该线程的许可；
	- 2. 该线程被中断；
	- 3. 设置的时间到了。并且，当time为绝对时间时，isAbsolute为true，否则，isAbsolute为false。当time为0时，表示无限等待，直到unpark发生。
-   unpark函数，释放线程的许可，即激活调用park后阻塞的线程。这个函数不是安全的，调用这个函数时要确保线程依旧存活。

## 文章
[独占锁与共享锁](https://blog.csdn.net/yjn1995/article/details/98979393)
[深入理解ReentrantLock实现](https://juejin.cn/post/6844903805683761165#heading-11)
[Unsafe](https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html)
[LockSupport](https://pdai.tech/md/java/thread/java-thread-x-lock-LockSupport.html)
[浅谈偏向锁、轻量级锁、重量级锁 - 简书](https://www.jianshu.com/p/36eedeb3f912)