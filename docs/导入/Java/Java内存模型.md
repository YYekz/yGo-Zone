### 基础
线程之间是如何通信以及线程之间如何同步呢？在命令式编程中有两种：**共享内存**和**消息传递**。
共享线程是在线程之间通过内存操作来**隐式**进行通信的。消息传递模型里，是没有公共状态的，是**显示**发送消息来进行通信。
Java并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。

Java 线程之间的通信由 JMM控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读 / 写共享变量的副本。（本地内存是JMM的一个抽象概念，并不真实存在，涵盖了缓存、写缓冲区、寄存器、编译器以及其他硬件的优化）

### 重排序

在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：
#### 编译器优化的重排序
编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都需要禁止）。
#### 指令级并行的重排序
现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
#### 内存系统的重排序
由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

指令级并行的重排序 和 内存系统的重排序都算是处理器重排序，JMM处理器重排序会要求java编译器生成指令序列时，插入特定类型的内存屏障指令来禁止特定类型的处理器重排序（同样不是所有处理器重排序都要禁止）。

为了保证内存可见性，java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM 把内存屏障指令分为下列四类：

| 屏障类型   | 指令示意                 | 说明                                                                         |
| ---------- | ------------------------ | ---------------------------------------------------------------------------- |
| LoadLoad   | Load1;LoadLoad;Load2     | 确保Load1数据装载先于Load2及后续所有装载指令                                 |
| StoreStore | Store1;StoreStore;Store2 | 确保Store1数据对其他处理器可见（刷新到主存），之前于Store2及后续所有存储指令 |
| LoadStore  | Load1;LoadStore;Store2   | 确保Load1数据装载先于Store2及后续所有存储指令刷新到主存                      |
| StoreLoad  | Store1;StoreLoad;Load2   | 确保Store1数据对其他处理器可见（刷新到主存），之前于Load2及后续所有装载指令  |
StoreLoad会使该屏障之前的所有内存访问指令（Load + Store）完成之后，才执行该屏障之后的内存访问指令，是一个“全能型”的屏障，同时具有其他三个屏障的效果，现代的处理器大多都支持（其他类型屏障不一定被所有处理器支持）。但执行该屏障**开销会很昂贵**，因为当前处理器通常要把写缓冲区的所有数据全部**刷新到内存**中（buffer fully flush）。

### happens-before
如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在*happens-before*关系。这里提到的两个操作既可以在同一线程，也可以在不同线程之间。与程序员密切相关的HB规则如下：
- 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作；
- 监视器锁规则：对一个监视器的解锁，happens-before于随后对这个监视器锁的加锁；
- volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读；
- 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C；

这里这个传递性有点不同，两个操作之间具有hb关系，并不意味着前一个操作必须在后一个操作之前执行！
hb仅仅要求**前一个操作（执行结果）对后一个操作可见**，且**前一个操作按顺序排在第二个操作之前**；这咋理解呢？

在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的提高开发的并行度。编译器和处理器遵循这一标准，从hb来看JMM其实同样遵循这个标准。

### as-if-serial 语义
是指：不管怎么重排序（编译器和处理器为了提高并行度），单线程下程序的执行结果都不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。
所以如果操作之间不存在**数据依赖**关系，这些操作可能被编译器、处理器重排序。

```java
	public class Example {  
  
    int a = 0;  
    boolean flag = false;  
  
    public void writer() {  
        a = 1;  
        flag = true;  
    }  
  
    public void reader() {  
        if (flag) {  //1
            int i = a;   //2
        }  
    }  
  
}
```
在代码中操作1和2存在**控制依赖**关系。当代码中存在控制依赖关系时，会影响指令序列执行的并行度。为此，编译器和处理器会采取**猜测**执行来客服控制相关性对并行度的影响。举个例子，线程B可以提前读取并计算`a*a`，然后把计算结果临时保存在一个名为**重排序缓冲**的硬件缓存中。当接下来flag判断为true时，直接把该结果写入变量i中。
所以重排序在这里是破坏了多线程程序的语义的。在单线程中，对存在控制以来的操作重排序是不会影响执行结果的（这也是为什么as-if-serial语义允许对存在控制依赖的操作做重排序的原因），但在多线程程序中，对存在控制依赖的操作重排序就可能会改变程序执行结果了。

### 顺序一致性

如果一个多线程程序能正确同步，那这个程序将是一个没有数据竞争的程序。
JMM对正确同步的多线程程序的内存一致性做了如下保证：
如果程序是正确同步的，程序的执行将具有顺序一致性，即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。这里的同步指的是广义上的同步，包括对常用同步原语（lock、volatile 和 final）的正确使用。

#### 顺序一致性内存模型

其实是一个理想化了的理论参考模型，为程序员提供了极强的内存可见性。有两大特性：
1. 一个线程中的所有操作必须按照程序的顺序来执行；
2. 不管程序是否同步，所有线程都只能看到一个单一的操作顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。

通俗点讲就是说在任一时间点最多只有一个线程可以连接内存来进行内存操作，当多线程并发时，就把所有线程的所有内存操作（读/写）串行化。
使用监视器正确同步后如下图：
![[Pasted image 20230210143007.png|300]]
若没有做线程同步，那可能如下图：
![[Pasted image 20230210143150.png|300]]
可以看到未同步程序一致性模型中虽然整体式无序的，但所有线程都能看到一个一致的整体执行顺序。之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见。
**但在JMM中就没有这个保证**。未同步的程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。最经典的例子就是当线程写数据到本地缓存中且没有刷新到主存之前，这个写操作就只有当前线程可见了，从其他线程的角度来看，这个写操作还没有被当前线程执行。只有当写操作的线程把本地内存中写的数据刷新到主存之后，这个操作才算是对其他线程可见。在这种情况下，当前线程和其他线程看到的操作执行顺序就不一致。

```java
public class Example {  
  
    int a = 0;  
    boolean flag = false;  
  
    public synchronized void writer() {  
        a = 1;  
        flag = true;  
    }  
  
    public synchronized void reader() {  
        if (flag) {  
            int i = a;  
        }  
    }  
  
}
```
这个例子，A线程执行*write*方法后，B线程执行*reader*方法。这是一个正确同步的多线程。根据JMM规则该程序的执行结果将于该程序在顺序一致性模型中的执行结果相同。
![[Pasted image 20230210144049.png|300]]
可以看到一个很明显的特点，在顺序一致性模型中，所有操作完全按照程序的顺序串行执行。但在JMM中，**临界区内的代码可以进行重排序**（但JMM不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义），JMM会在退出监视器和进入监视器这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图。（虽然A在临界区内做了重排序，但因为监视器互斥执行的特点，这种重排序既提高了执行效率，有没有改变执行结果）。

**JMM在具体实现的基本方针**：在不改变（正确同步的）程序执行结果的前提下，尽可能的为编译器和处理器的优化打开方便之门。

#### 那未同步程序的执行特性

那对于未同步或未正确同步的多线程，JMM只提供最小安全性：**线程执行时读到的值，要么是之前某个线程写入的值，要么是默认值，不会无中生有。**（其实很好理解，JVM在对上分配对象时，会先清空内存空间，然后才会在上面分配对象，JVM会同步这俩操作）。

未同步程序在这两个模型中的执行特性有以下几个差异：
1. 顺序一致性模型保证单线程内的操作会按照程序顺序执行，JMM不保证单线程内操作会按照顺序执行（重排序）；
2. 顺序一致性模型保证所有线程只能看到一致的操作执行顺序，JMM不保证所有线程都能看到一致的操作执行顺序（写缓存）；
3. 顺序一致性模型保证所有内存读、写操作都具有原子性，JMM不保证对64位的long和double型变量的内存读、写具有原子性；

> 前两个已经很清楚了，第三个与处理器总线的工作机制相关。在计算机中，数据通过总线在处理器和内存之间传递，每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步骤成为总线事务，包括读事务、写事务，每个事务都会读、写内存中一个或多个连续物理空间上的字。这里的关键是，总线会同步试图并发使用总线事务。在一个处理器执行总线事务期间，其总线会禁止其他处理器进行操作。如果这是有多个处理器并发向总线发起总线事务，会通过**总线仲裁**作出裁决，选一个执行，其他的等待。
> 总的来说，总线的这些工作机制把所有处理器堆内存的访问以串行化的方式来执行；在任一时间点，最多只有一个处理器能访问内存，从而保证了单个总线事务中的内存操作具有原子性。
> 在一些32位的处理器上，若要求对64位数据的读写操作具有原子性会有比较大的开销。所以为了照顾这种处理器，java语言规范古丽旦不强求JVM对64位的long、dobule型变量的内存操作具有原子性，会拆成两个32位的读写来执行。

### 总结

其实可以看出，越是追求性能的处理器，内存模型设计的会越弱。因为处理器希望内存模型对它的舒服越少越好，这样就可以尽可能多的优化提高性能。

由于常见的处理器内存模型比JMM姚若，所以java编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。（因为不同处理器有不同的内存模型，强弱也不相同，所以在不同平台为了展示同样的内存模型，JMM插入的内存屏障数量和种类也不相同）

JMM 对这两种不同性质的重排序，采取了不同的策略：

-   对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序。
-   对于不会改变程序执行结果的重排序，JMM 对编译器和处理器不作要求（JMM 允许这种重排序）。
![[Pasted image 20230210161047.png|300]]

JMM 对编译器和处理器的束缚已经尽可能的少。从上面的分析我们可以看出，JMM 其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。比如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再比如，如果编译器经过细致的分析后，认定一个 volatile 变量仅仅只会被单个线程访问，那么编译器可以把这个 volatile 变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。

Java 程序的内存可**见性保证按程序类型**可以分为下列三类：

-   **单线程程序**。单线程程序不会出现内存可见性问题。编译器，runtime 和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。
-   **正确同步的多线程程序**。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是 JMM 关注的重点，JMM 通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。
-   未同步 / 未正确同步的多线程程序。JMM 为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。

## 参考链接
[JVM 基础 - Java 内存模型详解 | Java 全栈知识体系](https://pdai.tech/md/java/jvm/java-jvm-jmm.html)