# HTTP的那些事儿 - 基础篇

## 概念普及

### URI与URL
URI的定义是统一资源标识符，表示的是一个资源可以被确定唯一性。

那确定唯一性有两种方式：
1. URL（统一资源定位符）也就是通过“位置”的方式找到这个唯一资源。举例：我找杭州市西湖区蒋墩路上的中学
2. URN（统一资源名称）也就是通过名称名称的形式去找到这个唯一资源；举例：我找西湖区的学军中学
严格来说，URI并不完全等同于网址，它包含**URL**和**URN**两个部分，在HTTP世界里的网址实际上是**URL**。但因为URL太普及了，所以尝尝将两者视为等价。

### MIME
多用途互联网邮件扩展”（Multipurpose Internet Mail Extensions）。
MIME 是一个很大的标准规范,HTTP只使用了其中的一部分，用来标记body的数据类型，这就是我们平常提到的**MIME type**。

### DNS
在 TCP/IP 协议中使用 IP 地址来标识计算机，数字形式的地址对于计算机来说是方便了，但对于人类来说却既难以记忆又难以输入。于是“域名系统”（Domain Name System）出现了。在 DNS 中，“域名”（Domain Name）又称为“主机名”（Host），为了更好地标记不同国家或组织的主机，让名字更好记，所以被设计成了一个有层次的结构。域名用“.”分隔成多个单词，级别从左到右逐级升高，最右边的被称为“顶级域名”。
> 其实HTTP协议中并没有要求必须使用DNS，但实际上为了方便访问互联网上的WEB服务器，通常都会使用DNS来定位主机名，间接的把DNS和HTTP绑定在了一起。

### CDN
全称是“Content Delivery Network”，翻译过来就是“内容分发网络”。它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。
简单来说，它可以缓存源站的数据，让浏览器的请求不用“千里迢迢”地到达源站服务器，直接在“半路”就可以获取响应。如果 CDN 的调度算法很优秀，更可以找到离用户最近的节点，大幅度缩短响应时间。

### TCP/IP/UDP
提到TCP/IP/UDP就不得不提协议栈，这个协议栈有四层，依次是：应用层、传输层（TCP）、网际层（IP）和链接层。

**IP 协议**是“Internet Protocol”的缩写，主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。IP 协议使用“IP 地址”的概念来定位互联网上的每一台计算机。就像我们生活中每个人的电话号码一样。

#### IPv4 和 IPv6
当前大多数使用的IP协议为v4版本，地址是用四组用“.”分隔开的数字，例如“192.168.0.1”，总共有2^32，大约42亿个可以分配的地址，看上去很多，但以目前互联网发展速度，已经捉襟见肘了。所以引出了IPv6，IPv6使用八组用“：”分隔开的数字，有2^128，足够当下使用。

**TCP协议**是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。所以其实HTTP只是一个传输协议，不关心寻址、路由、数据完整等传输细节，而这些细节都要求下层处理。

#### TCP/IP网络分层模型 和 OSI网络分层模型



### HTTP
HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。运行在TCP/IP协议之上。

### HTTPS
运行在SSL/TLS协议之上的HTTP。并不代表他使用SSL/TLS替换了TCP/IP，而是在TCP/IP之上，添加了SSL/TLS的加密操作。

### SSL/TLS
SSL 的全称是“Secure Socket Layer”，由网景公司发明，当发展到 3.0 时被标准化，改名为 TLS，即“Transport Layer Security”，但由于历史的原因还是有很多人称之为 SSL/TLS，或者直接简称为 SSL。SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲。

## HTTP协议报文
> TCP/UDP报文格式：拿TCP来举例，它在实际要传输的数据前附加了一个20字节的头部数据，存储TCP协议必须的额外信息，例如发送方的端口号、接收方的端口号、包序号、标志位等。

HTTP协议和TCP/UDP类似，同样也是传输时附加的一些头数据，不过不同的是，他是一个**纯文本**的协议，所以投书局都是ASCII码的文本，易于阅读。

HTTP协议的**请求报文**和**响应报文**结构基本相同，由三大部分组成：
1. 起始行(start line)：描述请求或响应的基本信息；
2. 头部字段集合(header)：使用key-value形式更详细地说明报文；
3. 消息正文(entity/body)：实际传输的数据，不一定是纯文本，可以是图片、视频等二进制数据；

HTTP协议规定报文必须有header，但可以没有body，而且在header之后必须有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。
![](media/16507169293624/16495800219720.jpg)

### 起始行
起始行也叫请求行，简要描述了客户端想要如何操作服务器端的资源。
由三部分构成：
1. 请求方法：如GET/POST，表示对资源的操作；
2. 请求目标：通常是一个URI，标记了请求方法要操作的资源；
3. 版本号：报文使用的HTTP协议版本。
三部分之间通常使用空格（space）来分隔，最后使用CRLF表示结束。
![](media/16507169293624/16495803078779.jpg)

### 状态行
对应于请求行，看看响应的起始行，称为**状态行**。
也是同样由三部分构成：
1. 版本号：报文使用的HTTp协议版本；
2. 状态码：三位数，用来代表处理结果，200是成功，500是服务器错误等；
3. 原因：作为数字补充，是更详细的文字解释。
![](media/16507169293624/16495804782511.jpg)

### 头部字段
请求头和响应头的结构是基本一样的，是key-value的形式，key与value之间用“:”分割，最后用CRLF换行表示结束。

HTTP头部字段非常灵活，不仅可以使用标准里的Host、Connect等已有头，还可以任意自定义头。
不过使用头字段需要注意下面几点：
1. 字段名不区分大小写，“Host”和“host”没区别，只是首字母大写可读性更好；
2. 字段名中不能出现空格，可以使用“-”，不能使用“_”；
3. 字段名后必须紧跟“:”，不能出现空格，但“:”后的字段值可以出现多个空格；
4. 字段的顺序是无意义的，可以任意排列；
5. 字段原则上不能重复，除非这个字段本身的语义允许，如Set-Cookie。

#### 常用头字段
HTTP协议规定了非常多的头部字段，实现不同的功能，但基本分为四大类：
1. 通用字段：在请求头和响应头里都能出现；
2. 请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；
3. 响应字段：仅能出现在响应头里，补充说明响应报文的信息；
4. 实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。

#### 一些key
**Host**，它属于请求字段，只能出现在请求头中，他也是唯一一个HTTP1.1规范里**必须出现**的字段，也就是说，请求头中如果没有Host，则是一个错误报文。

**Content-Length**，属于实体字段，表示报文里body的长度，也就是请求头或者响应头空行后的数据长度，服务器看到之后就知道后续有多少数据可以直接接收，如果没有这个字段，那么body就是不定长的，需要使用 chunked 方式分段传输。


## 请求方法
含义就是客户端发出一个“动作指令”，要求服务器对URI定位的资源执行这个动作。因为请求所有的动作都是需要服务端去响应的，所以所有的决定权都在服务端，是否真正做出操作或如何操作还是由服务器来决定的。
目前HTTP1/1.1 规定了八中方法，单词均全部大写：
1. GET：获取资源，可以理解为读取、下载数据；
2. HEAD：获取资源的元信息；
3. POST：向资源提交数据，相当于写入、上传数据；
4. PUT：类似POST；
5. DELETE：删除资源；
6. CONNECT：建立特殊的连接通道；
7. OPTIONS：列出可对资源实行的方法；
8. TRACE：追踪请求 - 响应的传输路径。

### GET/HEAD
**GET**方法比较简单，可配合URI和其他头字段实现对资源更精细的操作。
例如在URI后面使用“#”，就可以获取页面后直接定位到某个标签所在的位置；使用`If-Modified-Since`字段就变成了“有条件的请求”，仅当资源被修改时才会执行获取动作；使用`Range`字段就是“范围获取”，只获取资源的一部分数据；

**HEAD**和GET方法类似，可以理解为GET的轻量级版本，会返回和GET相同的响应头，但不会返回数据体，避免了传输body数据的浪费。
比如检查一个文件是否存在，或者检查某个文件是否有最新版本，就可用HEAD。

### POST/PUT
**POST**是向URI指定的资源提交报文body中的数据。

**PUT**和POST类似，也是向服务器提交数据，但存在微小的区别，通常POST指代的是新建“create”的意义，而PUT指的是修改“update”的意义。（但在实际中，PUT使用的很少，因为功能太过近似。）

### 其余方法

**DELETE** 服务器删除资源，因为动作危险性太大，所以通常不会执行对应的删除操作，而是给对应资源做删除标记，更多时候则不处理DELETE请求。

**CONNECT** 是一个比较特殊的方法，要求服务器为客户端和另一台远程服务器建立一条特殊的连接通道，这时Web服务器在中间充当了代理的角色。

**OPTIONS** 方法要求服务器列出可对资源实行的操作方法，在响应头的 Allow 字段里返回。它的功能很有限，用处也不大，有的服务器（例如 Nginx）干脆就没有实现对它的支持。

**TRACE** 方法多用于对 HTTP 链路的测试或诊断，可以显示出请求 - 响应的传输路径。它的本意是好的，但存在漏洞，会泄漏网站的信息，所以 Web 服务器通常也是禁止使用。

### 安全与幂等
还有两个比较重要的概念是**安全**和**幂等**。

在HTTP协议中，**安全**是指请求方法不会“破坏”服务器上的资源，也就是不会对服务器上的资源造成实质上的修改。所以在服务器不曲解请求方法的处理方式时，只有GET和HEAD是安全的。

**幂等**是一个数学用语，指的是多次幂运算后结果相同，在HTTP协议里，意思是多次执行相同操作，结果也相同。显然，HEAD、GET、DELETE都是幂等的，而POST会**新增**，多次创建资源，所以不幂等，而PUT指的是更新一个资源所以还是幂等的。

## URI的格式

URI最常见的形式是由 `scheme`、`host:post`、`path`和`query`四个部分组成，但部分可视情况省略。
![](media/16507169293624/16495998929819.jpg)

**scheme**是指协议名，表示资源使用哪种协议来访问，最常见的是http、https还有不太常见的例如ftp、file等。需要注意的是在`scheme`后必须是三个特定的字符：`://`。之后是**authority**的部分，表示资源所在的主机名，通常形式为：`host:post`，主机名+端口号。主机名可以使IP地址或者域名，必须要有，但端口号有时可以省略（浏览器等客户端回一句`scheme`使用默认端口号，例如HTTP默认端口号为80，HTTPS默认端口号为443）。再后面为标记资源所在的`path`，这里需要注意的是，`path`部分必须以“/”开始，也就是必须包含“/”。
> 关于`host:post`其实也是可以被省略的，例如 `file:///D:/http_study/www/` ，file类型的URI的特例，它允许省略主机名，默认是本机的localhost。但是对于HTTP或者HTTPS这种网络通信协议，主机名是绝对不能省略的，会导致找不到服务器。

在`path`之后，还有一个`query`部分，使用“?”开始，表示对资源附加的额外要求，查询的格式是多个`key=value`的字符串，这些key-value通过“&”连接。

URI的“真正”完成形态为：
![](media/16507169293624/16496006378282.jpg)
这个形态多了两部分信息：
1. 协议名后主机名前的身份信息`user:passwd@`，表示登陆主机时的用户名和密码，现在不推荐这种形式，因为敏感信息暴露，存在安全隐患。
2. 查询参数后的片段标识符“#fragment”，它是URI锁定为的资源内部的一个“锚点”或者说是“标签”，浏览器可以获取资源后直接跳转到指定位置。（但片段仅能由浏览器这样的客户端使用，服务器是看不到的，浏览器不会把带`#fragment`的URI发送给服务器，服务器也永远不会用这种方式去处理资源的片段）

**那URI里如果要使用其他语言怎么办呢？**
会使用encodeURI原理。将字符（unicode）编码成utf-8，utf-8是用1-4个字节表示的，所以将每个字节转换成16进制并在前面用`%`连接，最后把每个字节转换的结果连接起来。

## 响应状态码
RFC标准将状态码分为五类，数字第一位表示分类，100~599。五类具体含义为：
- 1xx：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；
- 2xx：成功，报文已经收到并且被正确处理；
- 3xx：重定向，资源位置发生临时或永久变动，需要客户端重新发送请求；
- 4xx：客户端错误，请求报文有误，服务器无法处理；
- 5xx：服务器错误，服务器在处理请求时内部发生了错误。
> 状态码不仅只有官方的标准分类，还可以自定义状态码逻辑，双方约定好对应逻辑即可。

### 一些常见的响应码
**200 OK**是最常见的成功状态吗，表示一切正常，如果是非HEAD请求通常都会有body数据。
**204 No Content**与200基本相同，但是响应头之后没有body数据。
**206 Partial Content**是HTTP分块下载或者断点续传的基础，在客户端返送“范围请求”要求获取资源的部分数据时会出现，和200的意义相同也是服务器正确的处理了请求，但是body里只是自愿的部分数据。（通常会伴随出现头字段`Content-Range`，表示响应报文中body数据的具体范围，便于客户端确认）
**301 Moved Permanently**俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用新的 URI 再次访问。
**302 Found**，曾经的描述短语是“Moved Temporarily”，临时重定向，意思是请求的资源还在，但要暂时使用另一个URI来访问。
**304 Not Modified**用于 `If-Modified-Sinice`等条件请求，表示资源未修改，用于缓存控制。不具有跳转含义，可以理解为**缓存重定向**。
**400 Bad Request**是一个通用错误码，表示请求报文有错，但具体错误原因未表明。
**403 Forbidden**并不是客户端的请求出错，而是服务器禁止访问该资源。
**404 Not Found**是资源在服务器上未找到，所以无法提供。（但目前被滥用，并不完全等价于标准中定义的资源为找到）
**500 Internal Server Error**和400类似，是一个通用错误码，具体服务器错误原因未表明。
**501 Not Implemented**表示客户端请求的功能还不支持。（类似即将开业，敬请期待）
**502 Bad Gateway**服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生错误，具体原因未知。
**503 Service Unavailable**表示服务器当前很忙，暂时无法响应服务，是一个临时的状态，可能再次访问就可以提供服务了，所以503响应报文里通常还会有一个`Retry-After`字段，表示客户端可以在多久之后再次尝试请求。

## HTTP的特点
具有以下几大主要特点：灵活可扩展、可靠传输、应用层协议、请求-应答的通信模式、无状态。
1. HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能；
2. HTTP 是可靠传输协议，基于 TCP/IP 协议“尽量”保证数据的送达；
3. HTTP 是应用层协议，比 FTP、SSH 等更通用功能更多，能够传输任意数据；
4. HTTP 使用了请求 - 应答模式，客户端主动发起请求，服务器被动回复请求；
5. HTTP 本质上是无状态的，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。

无状态这个特点解释一下：
**无状态**：无状态具体指的是*无记忆能力*，可以对比TCP来看，HTTP在整个协议中没有规定任何的状态，而且建立连接前两者互不知情且每次报文的收发也都是独立的，收发报文不会对双端产生任何影响，连接以后也不会保存任何信息。再对比下UDP，UDP是无连接+无状态，顺序发包乱序收包（不能保证顺序），发出去就不管了，收到以后也不会按照顺序整理，而HTTP则是有连接无状态，顺序发顺序收包，按照收发的顺序管理报文。

既然有这么多优点，那HTTP有什么缺点吗？当然有，人无完人，协议也一样。（下面说的缺点是针对HTTP 1.1）

1. 上文说到的**无状态**是把双刃剑，不只是优点也可能是缺点，如果没有状态保存的话，多个连续步骤的事务操作就无法进行，比如你浏览商品，下单，购物车，结账，支付一系列操作都需要知道当前操作的用户身份才行，那无状态服务器就无法知道这些请求的相关性，每一步操作都要身份信息，麻烦且增加不必要的数据传输量。
> 那话说回来，HTTP是怎么支持**状态**这个概念的呢？其实就是特点一的灵活可扩展，基于这一特性可以给他打补丁（Cookie）支持这个状态特性。
2. **明文**HTTP是明文传输，相比TCP、UDP这种二进制协议，优点显而易见，不需要任何外部的工具抓包即可轻松地查看和修改，但这样也会导致传输数据无任何隐私可言，他人也可以抓包获取，轻松修改，“免费wifi陷阱”说的就是这个，提供一个wifi热点，你连接上之后，流量都会通过他转发，如果你有转账或登陆等敏感操作，黑客就可以拿到这些数据冒充你。
3. **不安全** HTTP无校验机制，那怎么证明你就是你呢？还有就是无**完整性校验**，数据在传输过程中被截取或者修改也无法验证真伪。这也是HTTPS出现的原因。
4. **性能** HTTP是基于TCP/IP的协议，使用了**请求-应答**的通信模式，TCP的性能是不差的，但问题是，目前的互联网特点是移动和高并发，不能保证稳定的连接质量，加剧了**请求-应答**模式的性能问题，比如最著名的“队头阻塞”，顺序发送请求序列中的一个请求被某种原因阻塞时，后面的所有请求都阻塞，会导致客户端迟迟收不到接下来的所有数据。HTTP/2 解决了该问题。

概括一下HTTP的优缺点：
1. HTTP 最大的优点是简单、灵活和易于扩展；
2. HTTP 拥有成熟的软硬件环境，应用的非常广泛，是互联网的基础设施；
3. HTTP 是无状态的，可以轻松实现集群化，扩展性能，但有时也需要用 Cookie 技术来实现“有状态”；
4. HTTP 是明文传输，数据完全肉眼可见，能够方便地研究分析，但也容易被窃听；
5. HTTP 是不安全的，无法验证通信双方的身份，也不能判断报文是否被篡改；
6. HTTP 的性能不算差，但不完全适应现在的互联网，还有很大的提升空间。



